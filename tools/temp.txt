spreadsheet_model.py :

import sys
import json
from pathlib import Path
from PySide6.QtCore import (
    QAbstractTableModel,
    Qt,
    QUrl,
    QModelIndex,
    Slot,
    Property,
    Signal,
)
from PySide6.QtGui import QGuiApplication
from PySide6.QtQml import QQmlApplicationEngine
# from .generate_sortings import find_valid_sortings


class SpreadsheetModel(QAbstractTableModel):
    input_text_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._data = []
        self._rows_nb = 0
        self._columns_nb = 0
        self._collections = {
            "collections": {},
        }
        self._collectionName = self.getDefaultSpreadsheetName()
        self._maxRow = 0
        self._maxColumn = 0
        self._collection = {"maxRow": 0, "maxColumn": 0, "data": []}
        self._collections = {
            "collections": {self._collectionName: self._collection},
            "collectionName": self._collectionName,
        }
        try:
            with open(f"data/general.json", "r") as f:
                collections = json.load(f)
            if collections:
                self._collections = collections
                self._collectionName = collections["collectionName"]
                self._collection = collections["collections"].get(
                    self._collectionName, {}
                )
                self._maxRow = self._collection["maxRow"]
                self._maxColumn = self._collection["maxColumn"]
                self._data = self._collection["data"]
        except FileNotFoundError:
            # No saved data, initialize with defaults if needed
            pass
        except Exception as e:
            print(f"Error loading spreadsheet: {str(e)}")
        self.input_text_changed.emit()
    
    
    @Property(str, notify=input_text_changed)
    def input_text(self):
        """Property for the input text."""
        return self._collectionName

    @Slot(result=str)
    def getCollectionName(self):
        """Return the current collection name."""
        return self._collectionName

    @Slot(result=str)
    def getDefaultSpreadsheetName(self):
        """Generate a default spreadsheet name not already used."""
        i = 1
        while f"Default_{i}" in self._collections["collections"]:
            i += 1
        return f"Default_{i}"

    @Slot(str)
    def setSpreadsheetName(self, name):
        """Set the current spreadsheet name."""
        if name in self._collections["collections"]:
            return
        self.beginResetModel()
        self._collections["collections"][name] = self._collection
        del self._collections["collections"][self._collectionName]
        self._collectionName = name
        self.endResetModel()
        self.save_to_file()

    @Slot(str)
    def createCollection(self, name):
        """Create a new collection with the given name."""
        if name in self._collections["collections"]:
            name = self.getDefaultSpreadsheetName()
            self._collectionName = name
            self.input_text_changed.emit()
        self._collections["collections"][name] = {
            "data": [],
            "maxRow": 0,
            "maxColumn": 0,
        }
        self.beginResetModel()
        self._collectionName = name
        self._collection = self._collections["collections"][name]
        self._data = self._collection["data"]
        self._maxRow = 0
        self._maxColumn = 0
        self.endResetModel()
        self.save_to_file()

    @Slot(str)
    def deleteCollection(self, name):
        """Remove a collection by name."""
        if name in self._collections["collections"]:
            self.beginResetModel()
            del self._collections["collections"][name]
            if not self._collections["collections"]:
                self._collections["collections"] = {
                    self.getDefaultSpreadsheetName(): {
                        "maxRow": 0,
                        "maxColumn": 0,
                        "data": [],
                    }
                }
            self._collectionName = self._collections["collections"].keys()[0]
            self._collection = self._collections["collections"][self._collectionName]
            self._data = self._collection["data"]
            self._maxRow = self._collection["maxRow"]
            self._maxColumn = self._collection["maxColumn"]
            self.endResetModel()
            self.input_text_changed.emit()
            self.save_to_file()

    @Slot(str)
    def pressEnterOnInput(self, name):
        """Handle Enter key press on input field."""
        if not self.loadSpreadsheet(name):
            self.createCollection(name)

    @Slot(str, result=bool)
    def loadSpreadsheet(self, name):
        """Load a spreadsheet by name."""
        collection = self._collections["collections"].get(name, {})
        if collection:
            self.beginResetModel()
            self._collectionName = name
            self._collection = collection
            self._data = self._collection["data"]
            self._maxRow = self._collection["maxRow"]
            self._maxColumn = self._collection["maxColumn"]
            self.endResetModel()
            self.save_to_file()
            return True
        else:
            self.input_text_changed.emit()
            return False

    def rowCount(self, parent=None):
        return self._rows_nb

    def columnCount(self, parent=None):
        return self._columns_nb

    def data(self, index, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and index.isValid():
            return self._data[index.row()][index.column()]
        return None

    def setData(self, index, value, role=Qt.EditRole):
        if role == Qt.EditRole and index.isValid():
            row = index.row()
            col = index.column()
            self._data[row][col] = value
            if row >= self._maxRow:
                self._maxRow = row + 1
                self._collection["maxRow"] = self._maxRow
            if col >= self._maxColumn:
                self._maxColumn = col + 1
                self._collection["maxColumn"] = self._maxColumn
            # Emit dataChanged for both EditRole and DisplayRole
            self.dataChanged.emit(index, index, [Qt.EditRole, Qt.DisplayRole])
            self.save_to_file()
            return True
        return False

    @Slot(int)
    def addRows(self, count):
        if count <= 0:
            return
        new_row_count = self._rows_nb + count
        self.beginInsertRows(QModelIndex(), self._rows_nb, new_row_count - 1)
        self._rows_nb = new_row_count
        for _ in range(count):
            self._data.append([""] * self._columns_nb)
        self.endInsertRows()

    @Slot(int)
    def addColumns(self, count):
        if count <= 0:
            return
        new_col_count = self._columns_nb + count
        self.beginInsertColumns(QModelIndex(), self._columns_nb, new_col_count - 1)
        self._columns_nb = new_col_count
        for row in self._data:
            row.extend([""] * count)
        self.endInsertColumns()

    @Slot(int)
    def setRows(self, count):
        if count < 0:
            return
        if count < self._rows_nb:
            self.beginRemoveRows(QModelIndex(), count, self._rows_nb - 1)
            self._data = self._data[:count]
            self._rows_nb = count
            self.endRemoveRows()
        elif count > self._rows_nb:
            self.beginInsertRows(QModelIndex(), self._rows_nb, count - 1)
            for _ in range(count - self._rows_nb):
                self._data.append([""] * self._columns_nb)
            self._rows_nb = count
            self.endInsertRows()

    @Slot(int)
    def setColumns(self, count):
        if count < 0:
            return
        if count < self._columns_nb:
            self.beginRemoveColumns(QModelIndex(), count, self._columns_nb - 1)
            for row in self._data:
                row = row[:count]
            self._columns_nb = count
            self.endRemoveColumns()
        elif count > self._columns_nb:
            self.beginInsertColumns(QModelIndex(), self._columns_nb, count - 1)
            for row in self._data:
                row.extend([""] * (count - self._columns_nb))
            self._columns_nb = count
            self.endInsertColumns()

    @Slot(result=int)
    def getMaxRow(self):
        return self._maxRow

    @Slot(result=int)
    def getMaxColumn(self):
        return self._maxColumn

    def roleNames(self):
        return {Qt.DisplayRole: b"display"}

    @Slot(str, result=list)
    def getOtherCollectionNames(self, input_text):
        """Return a list of other collection names."""
        return [
            name
            for name in self._collections["collections"].keys()
            if name != input_text
        ]

    @Slot(str)
    def setCollectionName(self, name):
        """Set the current collection name."""
        if name not in self._collections["collections"]:
            self._collections["collections"][name] = {
                "maxRow": self._maxRow,
                "maxColumn": self._maxColumn,
                "data": self._data,
            }
            self._collectionName = name
            self.save_to_file()
        else:
            print(f"Collection '{name}' already exists.")

    def save_to_file(self):
        """Save model data to a JSON file."""
        with open(f"data/general.json", "w") as f:
            json.dump(self._collections, f)

    # @Slot()
    # def findSortings(self):
    #     """Call find_valid_sortings with the current spreadsheet data."""
    #     try:
    #         solutions = find_valid_sortings(self._data)
    #         print(f"Found solutions: {solutions}")
    #     except Exception as e:
    #         print(f"Error finding sortings: {str(e)}")


CellDelegate.qml :

import QtQuick

Rectangle {
    implicitWidth: tableView.cellWidth
    implicitHeight: tableView.cellHeight
    border.color: "lightgray"

    TextInput {
        anchors.fill: parent
        anchors.margins: 2
        text: model.display
        onEditingFinished: {
            console.log("Editing finished. New text: " + text)
            // Ensure the model is updated
            var modelIndex = tableView.model.index(model.row, model.column)
            // Pass value and EditRole as arguments
            var success = spreadsheetModel.setData(modelIndex, text, Qt.EditRole)
            if (!success) {
                console.error("Failed to update model data at index: " + model.index)
            }
        }
    }
}

FloatingWindow.qml :

import QtQuick
import QtQuick.Controls
import QtQuick.Layouts

Rectangle {
    id: floatingWindow
    property var tableView
    property var recommendations: []
    width: 300
    height: 200
    color: "lightblue"
    x: tableView.x + 10
    y: tableView.y + 10
    z: 1

    // Drag handling
    MouseArea {
        anchors.fill: parent
        drag.target: floatingWindow
        drag.axis: Drag.XAndYAxis
        drag.minimumX: tableView.x
        drag.maximumX: tableView.x + tableView.width - floatingWindow.width
        drag.minimumY: tableView.y
        drag.maximumY: tableView.y + tableView.height - floatingWindow.height
    }

    MouseArea {
        anchors.fill: parent
        enabled: dropdown.opened
        onPressed: (mouse) => {
            console.log("Mouse pressed at:", mouse.x, mouse.y)
            // Check Popup bounds using global coordinates
            const popupLeft = dropdown.x
            const popupRight = dropdown.x + dropdown.width
            const popupTop = dropdown.y
            const popupBottom = dropdown.y + dropdown.height
            
            // Check input field bounds using mapped coordinates
            const inputGlobal = inputField.mapToGlobal(0, 0)
            const inputLeft = inputGlobal.x
            const inputRight = inputLeft + inputField.width
            const inputTop = inputGlobal.y
            const inputBottom = inputTop + inputField.height
            
            // Test mouse position against both areas
            const inPopup = mouse.globalX >= popupLeft && mouse.globalX <= popupRight &&
                            mouse.globalY >= popupTop && mouse.globalY <= popupBottom
            
            const inInput = mouse.globalX >= inputLeft && mouse.globalX <= inputRight &&
                            mouse.globalY >= inputTop && mouse.globalY <= inputBottom

            // Close dropdown when clicking outside both areas
            if (!inPopup && !inInput) {
                dropdown.close()  // Close the dropdown
                inputField.forceActiveFocus()  // Maintain input focus
                inputField.text = spreadsheetModel.getCollectionName()
                // Removed mouse.accepted = true to allow event propagation
            }
        }
    }

    ColumnLayout {
        anchors.centerIn: parent
        spacing: 20

        RowLayout {
            spacing: 10
            Layout.alignment: Qt.AlignHCenter

            Button {
                text: "Rename"
                onClicked: spreadsheetModel.setCollectionName(inputField.text)
            }

            Button {
                text: "Create"
                onClicked: spreadsheetModel.createCollection(inputField.text)
            }

            Button {
                text: "Delete"
                onClicked: spreadsheetModel.deleteCollection(inputField.text)
            }
        }

        Item {
            Layout.preferredWidth: 200
            Layout.preferredHeight: 40

            TextField {
                id: inputField
                anchors.fill: parent
                placeholderText: "Type something..."
                font.pixelSize: 16
                padding: 10
                rightPadding: 40
                color: "#333333"
                selectionColor: "#2196F3"
                text: spreadsheetModel.input_text

                cursorDelegate: Rectangle {
                    visible: inputField.cursorVisible
                    color: "#2196F3"
                    width: 2
                    height: inputField.font.pixelSize + 4
                    y: 2
                }

                background: Rectangle {
                    color: "#ffffff"
                    border.color: inputField.activeFocus ? "#2196F3" : "#cccccc"
                    border.width: 1
                    radius: 5
                }

                onActiveFocusChanged: {
                    if (activeFocus) {
                        dropdown.open()
                    } else if (!dropdown.activeFocus) {
                        dropdown.close()
                    }
                }

                onPressed: dropdown.open()

                onAccepted: {
                    spreadsheetModel.pressEnterOnInput(inputField.text)
                    dropdown.close();
                }
                onTextChanged: {
                    recommendations = spreadsheetModel.getOtherCollectionNames(inputField.text)
                }
            }

            // Clear button
            Rectangle {
                id: clearButton
                anchors {
                    right: parent.right
                    verticalCenter: parent.verticalCenter
                    margins: 10
                }
                width: 20
                height: 20
                color: "transparent"
                visible: inputField.text.length > 0

                Text {
                    text: "Ã—"
                    anchors.centerIn: parent
                    font.pixelSize: 18
                    color: "#666"
                }

                MouseArea {
                    anchors.fill: parent
                    cursorShape: Qt.PointingHandCursor
                    onClicked: inputField.text = ""
                    hoverEnabled: true
                    onEntered: parent.color = "#f0f0f0"
                    onExited: parent.color = "transparent"
                }
            }

            // Dropdown list using Popup
            Popup {
                id: dropdown
                // property TextField inputFieldRef: inputField
                y: inputField.height + 5
                x: inputField.x
                width: inputField.width
                height: 150
                padding: 0
                closePolicy: Popup.CloseOnEscape

                onOpened: {
                    recommendations = spreadsheetModel.getOtherCollectionNames(
                        inputField.text
                    );
                    console.log("onOpened: ", recommendations)
                }

                background: Rectangle {
                    color: "#ffffff"
                    border.color: "#cccccc"
                    radius: 5
                }

                contentItem: ListView {
                    id: listView
                    anchors.fill: parent
                    anchors.margins: 5
                    clip: true
                    model: recommendations

                    delegate: Rectangle {   
                        width: listView.width
                        height: 30
                        color: mouseArea.containsMouse ? "#f0f0f0" : "transparent"

                        Text {
                            text: modelData
                            anchors.verticalCenter: parent.verticalCenter
                            leftPadding: 10
                            font.pixelSize: 14
                            color: "#333333"
                        }

                        MouseArea {
                            id: mouseArea
                            anchors.fill: parent
                            hoverEnabled: true
                            onClicked: {
                                inputField.forceActiveFocus();
                                spreadsheetModel.loadSpreadsheet(modelData);
                                inputField.text = modelData;
                            }
                        }
                    }
                    ScrollBar.vertical: ScrollBar {
                        policy: ScrollBar.AsNeeded
                    }
                }
            }
        }

        // Buttons
        RowLayout {
            spacing: 10
            Layout.alignment: Qt.AlignHCenter

            Button {
                text: "Sort"
                // onClicked: spreadsheetModel.findSortings()
            }

            Button {
                text: "Button 2"
            }
        }
    }
}

MainLayout.qml :

import QtQuick
import QtQuick.Controls
import QtQuick.Layouts

RowLayout {
    id: mainLayout
    property alias tableView: tableView
    anchors.fill: parent
    spacing: 0

    RowHeader {}

    SpreadsheetTableView {
        id: tableView
    }
}

RowHeader.qml :

import QtQuick
import QtQuick.Controls
import QtQuick.Layouts

ListView {
    id: rowHeader
    Layout.preferredWidth: 40
    Layout.fillHeight: true  // Add this line
    model: spreadsheetModel.rowCount()
    boundsBehavior: Flickable.StopAtBounds
    interactive: false
    clip: true

    delegate: Rectangle {
        width: rowHeader.width
        height: tableView.cellHeight
        color: "#f0f0f0"
        border.color: "#cccccc"
        
        Text {
            text: index + 1
            anchors.centerIn: parent
            font.pixelSize: 12
        }
    }

    contentY: tableView.contentY

    Connections {
        target: spreadsheetModel
        function onRowsInserted(parent, first, last) { 
            rowHeader.model = spreadsheetModel.rowCount(); 
        }
        function onRowsRemoved(parent, first, last) { 
            rowHeader.model = spreadsheetModel.rowCount(); 
        }
    }
}

SpreadsheetTableView.qml :



main.qml :



main.py :

